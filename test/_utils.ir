::TestBase
  @name\s\$
  @success\b\ true
  @testName\s\ ''

:run
  @init()
  @ackStart()
  @runTests()
  @report(@success ? 'GOOD' : 'BAD')

:@init
  window.onerror = ##
    err\s\$
    file\s\$
    line\n\$
    @success = false
    @report(#)
      'error: ' + err
      '    ' + file + ' (line ' + line + ')'
    => true

:@ackStart
  xhrPost('/_tr', '<<<Test:' + @name + '>>>')

:@runTests
  // run all the methods that has names starting with 'test'.
  each m in @
    if /^test/.test(m) && typeof(@[m]) == 'function'
      @testName = m
      try
        @[m].apply(@)
      catch e
        @success = false
        @reportException(e)
      @testName = ''
      @clear()

:@clear
  f_page.clear()

:@sendKeyCode
  code\n\$
  shift\b\? false
  // There seems to be webkit bug that KeyboardEvent not allowing keyCode to be set.
  e := &Event('keyup')
  e.keyCode = code
  e.shiftKey = shift
  e.target = document.body
  document.body.dispatchEvent(e)

:@sendKeys
  kstr\s\$
  shift\b\? false
  kstr.split('').forEach(##)
    kchar\s\$
    @sendKeyCode(c(kchar.toUpperCase()), shift)

:@sendInput
  str\s\$
  sel := window.getSelection()
  node := sel.anchorNode
  offset := sel.anchorOffset
  if node instanceof Text
    current_str := node.wholeText
    node.replaceWholeText(#)
      current_str.substr(0, offset)
      str
      current_str.substr(offset)
    sel.collapse(node, offset + str.length)
  else
    node.innerText = str

:@mouseDispatch
  element\Element\$
  event_name\s\$
  x\n\?
  y\n\?
  opts = {target: element}
  if x !== undefined
    opts.clientX = x
  if y !== undefined
    opts.clientY = y
  element.dispatchEvent(&MouseEvent(event_name, opts))

:@sendDrag
  x0\n\$
  y0\n\$
  x1\n\$
  y1\n\$
  el := dom.id('input_layer')
  @mouseDispatch(el, 'mousedown', x0, y0)
  for i := 0; i <= 10; i++
    a := 0.1 * i
    @mouseDispatch(el, 'mousemove', #, #)
      a * x0 + (1.0 - a) * x1
      a * y0 + (1.0 - a) * y1
  @mouseDispatch(el, 'mouseup', x1, y1)

:@sendClickToButton
  name\s\$
  @mouseDispatch(dom.id('button_' + name), 'click')

:@select
  sel\s\$
  => document.querySelector(sel)

:@verify
  cond\b\$
  if cond
    =>
  @success = false
  try
    // Make an error to get the stack trace.
    throw &Error()
  catch e
    @reportException(e, 'failure')

:@report
  line\s\$
  desc\s\? ''
  xhrPost('/_tr', '* [' + # + '] ' + line + #)
    @testName ? @name + '.' + @testName : @name
    desc ? '\n' + desc : ''

:@reportException
  e\Error\$
  title\s\?
  stack_lines := e.stack.split('\n')
  title_line = title || stack_lines[0]
  @report(#)
    title_line + ':'
    stack_lines.slice(1).filter(##).join('\n')
      line\s\$
      // Dropping the stacks that belong to this class.
      => !/^\s*at\s+TestBase\./.test(line)

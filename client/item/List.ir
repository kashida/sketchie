::
  @list\Element\ id('itemlist')

:children+\NodeList\
  => @list.childNodes
:childrenArray+\A.<Node>\
  arr := []
  eachChild(@list, ##)
    c\Element\$
    arr.push(c)
  => arr

:first
  => @.children[0]
:last
  => @.children[@.children.length - 1]
:length
  => @.children.length
:empty
  => @.children.length == 0
:child
  index\n\$
  if index < 0
    index += @.length()
  => @.children[index]

:each
  handler\F\$
  eachChild(@list, ##)
    item\Element\$
    handler(item)

:until
  back_to_front\b\$
  handler\F\$
  c := @.children
  if back_to_front
    for i := 0; i < c.length; i++
      if handler(c[i])
        =>
  else
    for i := c.length - 1; i >= 0; i--
      if handler(c[i])
        =>

:zOrder
  items\A.<Element>\$
  => @.childrenArray.filter(##)
    item\Node\$
    => items.indexOf(item) >= 0

:remove
  items\Element|A.<Element>\$
  if items instanceof Element
    @list.removeChild(items)
  else
    items.forEach(##)
      item\Element\$
      @list.removeChild(item)

:insertFirst
  items\A.<Element>\$
  items.forEach(##)
    item\Element\$
    @list.insertBefore(item, @list.firstChild)

:appendEnd
  items\Element|A.<Element>\$
  if items instanceof Element
    @list.appendChild(items)
  else
    items.forEach(##)
      item\Element\$
      @list.appendChild(item)

:insertBefore
  pivot\Element\$
  items\A.<Element>\$
  if pivot
    items.forEach(##)
      item\Element\$
      @list.insertBefore(item, pivot)
  else
    @.appendEnd(items)

:insertAfter
  pivot\Element\$
  items\A.<Element>\$
  if pivot.nextSibling
    items.forEach(##)
      item\Element\$
      @list.insertBefore(item, pivot.nextSibling)
  else
    @.appendEnd(items)

:replace
  orig_item\Element\$
  new_item\Element\$
  next := orig_item.nextSibling
  @list.removeChild(orig_item)
  if next
    @list.insertBefore(new_item, next)
  else
    @list.appendChild(new_item)

:top
  handler\F\$
  => @.topIn(@.childrenArray, handler)
:topIn
  nodes\A.<Element>\$
  handler\F\$
  top_y := null
  top_item := null
  nodes.forEach(##)
    c\Element\$
    if !top_y || c.offsetTop < top_y
      top_y = c.offsetTop
      top_item = c
  if top_item
    handler(top_item, top_y)

:bottom
  handler\F\$
  => @bottomIn(@.childrenArray, handler)
:@bottomIn
  nodes\A.<Element>\$
  handler\F\$
  bottom_y := null
  bottom_item := null
  nodes.forEach(##)
    c\Element\$
    if !bottom_y || c.offsetTop > bottom_y
      bottom_y = c.offsetTop
      bottom_item = c
  if bottom_item
    handler(bottom_item, bottom_y)

All the items that are afeter the specified item (exclusive).
:after\A.<Element>\
  item\Element\$
  for i := 0; i < @.children.length; i++
    if @.children[i] == item
      // We can't use array.slice because children is a NodeList.
      list := []
      for j := i + 1; j < @.children.length; j++
        list.push(@.children[j])
      => list
  // item didn't appear in the list.
  => null

TODO: setZ and clearZ dons't seem to be used.
:setZ
  init\n\$
  step\n\? 1
  i := init
  @.each(##)
    item\Element\$
    item.style['zIndex'] = i
    i += step

:clearZ
  @.each(##)
    item\Element\$
    item.style['zIndex'] = null

::
  @list\!Element\ id('itemlist')
  eachChild(@list, ##)
    el\!Element\$
    if !el.item
      &%.Item(el)

All child elements need to be blessed when added, and disposed when removed.
:@dispose
  item\!%.Item\$
  @list.removeChild(item.element)
  item.dispose()

:children+\NodeList\
  => @list.childNodes
:childrenArray+\!A.<%.Item>\
  arr := []
  eachChild(@list, ##)
    el\Element\$
    arr.push(\!%.Item\(el.item))
  => arr

:first
  => @.children[0]
:last
  => @.children[@.children.length - 1]
:length
  => @.children.length
:empty
  => @.children.length == 0
:child
  index\n\$
  if index < 0
    index += @.length()
  => @.children[index]

:each
  handler\f(!%.Item, Element)\$
  eachChild(@list, ##)
    el\Element\$
    handler(\!%.Item\(el.item), el)

:until
  back_to_front\b\$
  handler\F\$
  c := @.children
  if back_to_front
    for i := 0; i < c.length; i++
      if handler(c[i])
        =>
  else
    for i := c.length - 1; i >= 0; i--
      if handler(c[i])
        =>

:zOrder
  items\!A.<!%.Item>\$
  => @.childrenArray.filter(##)
    item\%.Item\$
    => items.indexOf(item) >= 0

:remove
  items\!%.Item|!A.<!%.Item>\$
  if items instanceof %.Item
    @dispose(items)
  else
    items.forEach(##)
      item\!%.Item\$
      @dispose(item)

:insertFirst
  items\A.<!%.Item>\$
  items.forEach(##)
    item\!%.Item\$
    @list.insertBefore(item.element, @list.firstChild)

:appendEnd
  items\!%.Item|!A.<!%.Item>\$
  if items instanceof %.Item
    @list.appendChild(items.element)
  else
    items.forEach(##)
      item\!%.Item\$
      @list.appendChild(item.element)

:insertBefore
  pivot\%.Item\$
  items\!A.<!%.Item>\$
  if pivot
    items.forEach(##)
      item\!%.Item\$
      @list.insertBefore(item.element, pivot.element)
  else
    @.appendEnd(items)

:insertAfter
  pivot\!%.Item\$
  items\!A.<!%.Item>\$
  if pivot.element.nextSibling
    items.forEach(##)
      item\!%.Item\$
      @list.insertBefore(item.element, pivot.element.nextSibling)
  else
    @.appendEnd(items)

:replace
  orig_item\!%.Item\$
  new_item\!%.Item\$
  next := orig_item.element.nextSibling
  @dispose(orig_item)
  if next
    @list.insertBefore(new_item.element, next)
  else
    @list.appendChild(new_item.element)

:top
  handler\F\$
  => @.topIn(@.childrenArray, handler)
:topIn
  items\!A.<!%.Item>\$
  handler\F\$
  top_y := null
  top_item := null
  items.forEach(##)
    item\!%.Item\$
    el := item.element
    if !top_y || el.offsetTop < top_y
      top_y = el.offsetTop
      top_item = el
  if top_item
    handler(top_item, top_y)

:bottom
  handler\F\$
  => @bottomIn(@.childrenArray, handler)
:@bottomIn
  nodes\!A.<!%.Item>\$
  handler\F\$
  bottom_y := null
  bottom_item := null
  nodes.forEach(##)
    item\!%.Item\$
    el := item.element
    if !bottom_y || el.offsetTop > bottom_y
      bottom_y = el.offsetTop
      bottom_item = el
  if bottom_item
    handler(bottom_item, bottom_y)

All the items that are afeter the specified item (exclusive).
:after\A.<!%.Item>\
  item\%.Item\$
  for i := 0; i < @.children.length; i++
    if @.children[i] == item.element
      // We can't use array.slice because children is a NodeList.
      list := []
      for j := i + 1; j < @.children.length; j++
        list.push(@.children[j])
      => list
  // item didn't appear in the list.
  => null

TODO: setZ and clearZ dons't seem to be used.
:setZ
  init\n\$
  step\n\? 1
  i := init
  @.each(##)
    item\!%.Item\$
    item.style['zIndex'] = i
    i += step

:clearZ
  @.each(##)
    item\!%.Item\$
    item.style['zIndex'] = null

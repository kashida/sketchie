::

:moveToEnd
  items\!A.<!%.Item>\$
  send_back\b\$
  // Preserve the z order among the selected items.
  remove_list := f_page.items.zOrder(items)
  //f_page.items.removeNoDispose(remove_list)
  if send_back
    f_page.items.insertFirst(remove_list)
  else
    f_page.items.appendEnd(remove_list)

:shiftOne
  item\!%.Item\$
  send_back\b\$
  // TODO: move only the items in viewport.
  idx := f_page.items.indexOf(item)
  if send_back
    prev_item := f_page.items.childAt(idx - 1)
    if prev_item
      //f_page.items.removeNoDispose(item)
      f_page.items.insertBefore(prev_item, [item])
  else
    next_item := f_page.items.childAt(idx + 1)
    if next_item
      //f_page.items.removeNoDispose(item)
      f_page.items.insertAfter(next_item, [item])

:shiftOneWithOverlap
  send_back\b\$
  // First find a selected item and then find a non-selected item that has
  // overlapping region with one of the selected items.
  found_selected := []
  to_move := []
  found := false
  f_page.items.until(send_back, ##)
    item\model.Item\$
    if f_page.selection.isSelected(item)
      found_selected.push(item)
    else if found_selected.length > 0
      to_move.push(item)
      if dom.overlapWithAny(item.element, found_selected.map(##))
        item\%.Item\$
        => item.element
        --
        // All the non-selected items after the first selected maybe
        // non-overlapping, so we need this flag.
        found = true
        => true
    => false
  if to_move.length > 0 && found
    //f_page.items.remove(to_move)
    if send_back
      f_page.items.insertBefore(found_selected[0], to_move)
    else
      f_page.items.insertAfter(found_selected[0], to_move)

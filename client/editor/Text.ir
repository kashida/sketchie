::<%.Editor
  @selection\item.Selection\$
  ^()

:<deactivate

:@trimWhitespace
  str\s\$
  => str.replace(/^\s+/, '').replace(/\s+$/, '')

:@trimEndWhitespace
  str\s\$
  => str.replace(/^[\r\n]*/, '').replace(/\s+$/, '')

:@minimumTextDiv
  str\s\? ''
  div := create('div')
  div.appendChild(create('br'))
  if str
    div.appendChild(createText(@trimWhitespace(str)))
  => div

If remove is true, clean up empty div's and remove the item if it ends up empty.
:@normalizeTextItem
  remove\b\$
  if !@selection.isHeadText
    =>
  sel := @selection.head
  sel.normalize()
  // Remove end spaces from all the text nodes.
  eachChild(sel, ##)
    div\Element\$
    div.innerText = @trimEndWhitespace(div.innerText)
  // Remove empty first and last elements.
  if remove
    while sel.firstChild && sel.firstChild.innerText == ''
      sel.removeChild(sel.firstChild)
    while sel.lastChild && sel.lastChild.innerText == ''
      sel.removeChild(sel.lastChild)
  // Re-insert br tag to now empty div's.
  eachChild(sel, ##)
    div\Element\$
    if div.innerText == ''
      div.appendChild(create('br'))
  // Remove the element if there's nothing left.
  if remove && sel.childNodes.length == 0
    @selection.clear()
    sel.blur()
    f_page.items.remove(sel)

:collapseTexts
  // Collapse texts in y order.
  elems := []
  first_position := null
  while @selection.isAny
    f_page.items.topIn(@selection.list, ##)
      item\Element\$
      while item.firstChild
        c := item.firstChild
        item.removeChild(c)
        elems.push(c)
      if !first_position
        first_position = [item.offsetLeft, item.offsetTop]
      @selection.remove(item)
      f_page.items.remove(item)

  // Create an empty text item and add the elements.
  newtext := @makeTextItem('')
  newtext.removeChild(newtext.firstChild)
  elems.forEach(##)
    elem\Element\$
    newtext.appendChild(elem)
  f_page.items.appendEnd(newtext)
  newtext.style.left = first_position[0] + 'px'
  newtext.style.top = first_position[1] + 'px'
  @selection.select(newtext)

:@splitTextbox
  if !@selection.isHeadText
    =>
  sel := @selection.head
  cursor := window.getSelection()

  // Find the div the cusor is in now.
  until_children := ##
    node\Element\$
    pred\F\$
    i := 0
    while i < node.childNodes.length
      if pred(node.childNodes[i])
        => i
      i++
    => -1
  remove_and_convert_rest_to_str := ##
    node\Element\$
    index\n\$
    str := ''
    i := index
    while i < node.childNodes.length
      c := node.childNodes[i]
      str += nodeText(c)
      node.removeChild(c)
    => str
  newstr := ''
  cursor_div_index := until_children(sel, ##)
    c\Element\$
    if c == cursor.anchorNode
      newstr = remove_and_convert_rest_to_str(c, cursor.anchorOffset)
      => true
    if c == cursor.anchorNode.parentNode
      cursor_elem_index := until_children(c, ##)
        cc\Element\$
        if cc == cursor.anchorNode
          newstr = cc.nodeValue.substr(cursor.anchorOffset)
          cc.nodeValue = cc.nodeValue.substr(0, cursor.anchorOffset)
          => true
        => false
      newstr += remove_and_convert_rest_to_str(c, cursor_elem_index + 1)
      => true
    => false

  // Move all the rest div's to a new item.
  newtext := @makeTextItem(newstr, sel)
  i := cursor_div_index + 1
  while i < sel.childNodes.length
    c = sel.childNodes[i]
    sel.removeChild(c)
    newtext.appendChild(c)
  f_page.items.appendEnd(newtext)

  // Remove the previous item if there's no text now.
  @makeEditable(false)
  @normalizeTextItem(true)

  // Activate the new item.
  @selection.select(newtext)
  @normalizeTextItem(false)
  @makeEditable()
  newtext.focus()
  window.getSelection().collapse(newtext, 0)

:addText
  create_new\b\$
  cursor_top\b\? false
  if !(create_new || @selection.isHeadText)
    =>
  if create_new
    // Add a text box at the right location and make it visible.
    text := @makeTextItem('', @selection.head)
    f_page.items.appendEnd([text])
    @selection.select(text)

  @makeEditable()
  f_editor_modes.changeModeTo('t')
  window.getSelection().collapse(#)
    @selection.head
    cursor_top ? 0 :@selection.head.innerText.length
  @selection.head.focus()

:@makeEditable
  start\b\? true
  text\s\? null
  if !(text || @selection.isHeadText)
    =>
  text = text || @selection.head
  text.contentEditable = start
  text.style['-webkit-user-select'] = start ? 'text' : 'none'

:copyTextItem
  orig_item\Element\$
  item := @makeTextItem(orig_item.innerText)
  item.style.left = (orig_item.offsetLeft + 10) + 'px'
  item.style.top = (orig_item.offsetTop + 10) + 'px'
  f_page.items.appendEnd([item])

:@makeTextItem\Element\
  str\s\$
  ref_item\Element\?
  x := window.pageXOffset
  y := window.pageYOffset
  if ref_item
    x = ref_item.offsetLeft - 5
    y = ref_item.offsetTop + ref_item.clientHeight + 2
  text := create('div')
  text.appendChild(@minimumTextDiv(str))
  &%.Item(text, @selection)
  @makeEditable(false, text)
  text.style.left = x + 'px'
  text.style.top = y + 'px'
  => text

:@commitTextbox
  if !@selection.isHeadText
    =>
  @makeEditable(false)
  @normalizeTextItem(true)
  f_editor_modes.popMode()

Make sure there is at least one div left when there is backspace in text
edit mode.
:@textBackspace
  if !@selection.isHeadText
    =>
  sel := @selection.head
  sel.normalize()
  if sel.childNodes.length == 1 && sel.firstChild.tagName == 'BR'
    sel.removeChild(sel.firstChild)
  if sel.childNodes.length != 0
    =>
  sel.appendChild(@minimumTextDiv())
  window.getSelection().collapse(sel, 0)

:dispatch
  evt\Event\$
  if evt.keyCode == DOM_VK_RETURN && evt.shiftKey
    @splitTextbox()

  else if evt.keyCode == DOM_VK_ESCAPE
    @commitTextbox()

  else if evt.keyCode == DOM_VK_BACK_SPACE
    @textBackspace()

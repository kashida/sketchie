Canvas that's fixed to the viewport size.
::<Canvas
  canvas_or_w\HTMLCanvasElement|n\$
  h\n\?
  ^(canvas_or_w, h)

:activate
  img\Image\?
  img_pos\data.Vec2\?
  alpha_lock\b\? false
  // Need to match the backing store resolution with screen resolution.
  @.canvas.style.display = 'block'
  @.setScale(f_viewport.scale())
  if img && img_pos
    @.copyImage(img, img_pos)
  @.updateAlphaLock(alpha_lock)

:updateAlphaLock
  alpha_lock\b\$
  @.ctx.globalCompositeOperation = alpha_lock ? 'source-atop' : 'source-over'

:deactivate
  @.clear()
  @.canvas.style.display = 'none'
  @.ctx.globalCompositeOperation = ''

Val is the opacity value [0, 1.0], but resets to default when null.
:opacity*
  val\?s|n\$
  @.canvas.style.opacity = val

Takes view coordinates and returns [r, g, b, a] array in [0, 255] range.
:pickColor\data.Color\
  x\n\$
  y\n\$
  scale := f_viewport.scale()
  pixels := @.ctx.getImageData(x / scale, y / scale, 1, 1)
  d := pixels.data
  => data.Color.fromByteRange(d[0], d[1], d[2], d[3])

:imageSpec\pixel.PositionedPixels\
  orig_img\Image\?
  // Produce image spec of this surface plus the original image.
  // Size of the image is reduced to the tight bound.
  pixels := @.pixels()
  => #?
    orig_img
    %.Surface.mergedImageSpec(pixels, orig_img)
    %.Surface.imageRectSpec(pixels)

Orig_img gets added to the outside of the pixels bound.
Pixels_rect is the tight bounds of the pixels in canvas (i.e. viewport) coordinates.
:mergedImageSpec = ##
  \pixel.PositionedPixels\
  pixels\ImageData\$
  orig_img\Image\$
  pixels_rect := %.Surface.findPixelRect(pixels)
  if !pixels_rect
    => null
  w := pixels_rect.w + 1
  h := pixels_rect.h + 1

  // Find the rect that can contain pixels_rect and the transformed image
  // in document coords.
  img0 := f_viewport.itemToSurface(elemPosition(orig_img))
  img1 := f_viewport.itemToSurface(elemPositionBR(orig_img))
  u := unionRect([orig_img], pixels_rect, [[img0.x, img0.y, img1.x, img1.y]])
  if !u
    => null
  uw := u.w + 1
  uh := u.h + 1

  // New temp canvas, logically located at (u.x0, u.y0) in surface coords.
  cvs := &Canvas(uw, uh)
  ctx := cvs.ctx
  %.xformDrawImage(ctx, orig_img, &data.Vec2(img0.x - u.x0, img0.y - u.y0))
  ctx.clearRect(-u.x0, -u.y0, pixels.width, pixels.height)
  ctx.putImageData(pixels, -u.x0, -u.y0, pixels_rect.x0, pixels_rect.y0, w, h)
  => %.Surface.imageRectSpec(cvs.pixels(), undefined, u.p00)

:imageRectSpec = ##
  \pixel.PositionedPixels\
  pixels\ImageData\$
  rect\!data.Rect\? %.Surface.findPixelRect(pixels)
  offset\!data.Vec2\? &data.Vec2(0, 0)
  if !rect
    => null
  item_xy := f_viewport.surfaceToItem(&data.Vec2(#))
    rect.x0 + offset.x
    rect.y0 + offset.y
  => &pixel.PositionedPixels(item_xy, %.Surface.sizedImageData(pixels, rect))

::xformDrawImage = ##
  ctx\CanvasRenderingContext2D\$
  img\Image\$
  offset\data.Vec2\$
  use_alpha\b\? false
  xf_r := attr(img, 'xf_r')
  xf_s := attr(img, 'xf_s')
  alpha := use_alpha ? attr(img, 'blend_alpha') : null
  if !(xf_r || xf_s || alpha)
    ctx.drawImage(img, offset.x, offset.y)
    =>
  half_w := 0.5 * img.width
  half_h := 0.5 * img.height
  ctx.save()
  ctx.translate(offset.x + half_w, offset.y + half_h)
  if xf_r
    ctx.rotate(xf_r)
  if xf_s
    ctx.scale(xf_s, xf_s)
  if alpha
    ctx.globalAlpha = parseInt(alpha, 10) / 100.0
  ctx.drawImage(img, -half_w, -half_h)
  ctx.restore()

::imageRegion = ##
  \pixel.PositionedPixels\
  img\Image\$
  img_pos\data.Vec2\$
  mask\ImageData\$
  diff\b\? false
  // Take either intersection or diff of the images.
  cvs := &Canvas(img.width, img.height)
  cvs.ctx.drawImage(img, 0, 0)
  pixels := cvs.pixels()
  sti := f_viewport.surfaceToItem(&data.Vec2(0, 0))
  %.Surface.intersectPixelRegion(#)
    pixels
    mask
    Math.floor(img_pos.x - sti.x)
    Math.floor(img_pos.y - sti.y)
    diff
  rect := %.Surface.findPixelRect(pixels)
  if !rect
    => null
  => &pixel.PositionedPixels(#)
    &data.Vec2(rect.x0 + img_pos.x, rect.y0 + img_pos.y)
    %.Surface.sizedImageData(pixels, rect)

::blendImages = ##
  \pixel.PositionedPixels\
  images\!A.<!model.Image>\$
  if images.length < 1
    => null
  ur := unionRect(images.map(##))
    item\!model.Image\$
    => item.img
  minx := ur.x0
  miny := ur.y0
  maxx := ur.x1
  maxy := ur.y1
  w := maxx - minx + 1
  h := maxy - miny + 1
  cvs := &Canvas(w, h)
  ctx := cvs.ctx
  images.forEach(##)
    item\!model.Image\$
    %.xformDrawImage(ctx, item.img, &data.Vec2(#), true)
      item.position.x - minx
      item.position.y - miny

  // Now we have the image. Find a tighter bound.
  pixels := cvs.pixels()
  rect := %.Surface.findPixelRect(pixels)
  if !rect
    => null
  => &pixel.PositionedPixels(#)
    &data.Vec2(rect.x0 + minx, rect.y0 + miny)
    %.Surface.sizedImageData(pixels, rect)

:findPixelRect = ##
  \data.Rect\
  pixels\ImageData\$
  // Find the rectangle in the image where pixels actually have colors.
  // Resulting coordinates are relative to the pixels.
  miny := minx := maxy := maxx := null
  has_value := ##
    x\n\$
    y\n\$
    // only check alpha.
    => pixels.data[(x + y * pixels.width) * 4 + 3] > 0

  // Find the minimum and maximum y values that has any pixel.
  row_has_value := ##
    y\n\$
    for x := 0; x < pixels.width; x++
      if has_value(x, y)
        => true
    => false
  for y := 0; y < pixels.height; y++
    if row_has_value(y)
      miny = y
      break
  if miny === null
    => null
  for y = pixels.height - 1; y >= miny; y--
    if row_has_value(y)
      maxy = y
      break
  if maxy === null
    => null

  // Find the minimum and maximum x values that has any pixel.
  col_has_value := ##
    x\n\$
    for y = miny; y <= maxy; y++
      if has_value(x, y)
        => true
    => false
  for x := 0; x < pixels.width; x++
    if col_has_value(x)
      minx = x
      break
  if minx === null
    => null
  for x = pixels.width - 1; x >= minx; x--
    if col_has_value(x)
      maxx = x
      break
  if maxx === null
    => null
  => &data.Rect(minx, miny, maxx, maxy)

::unionRect = ##
  \data.Rect\
  images\A.<Image>\$
  init_rect\data.Rect\?
  image_dimensions\A\? []
  if images.length < 1
    => null
  result := init_rect ? init_rect.clone : null
  images.forEach(##)
    img\Image\$
    i\n\$
    img_rect := image_dimensions.length > i ? # : #
      &data.Rect(#)
        image_dimensions[i][0]
        image_dimensions[i][1]
        image_dimensions[i][2]
        image_dimensions[i][3]
      elemRect(img)
    xf_r := attr(img, 'xf_r')
    xf_s := attr(img, 'xf_s')
    xfm_rect := img_rect.clone
    if xf_r || xf_s
      half_w := 0.5 * img_rect.w
      half_h := 0.5 * img_rect.h
      // Corner coord from the center of the image (doesn't matter which
      // corner).
      x := half_w
      y := half_h
      if xf_s
        x = x * xf_s
        y = y * xf_s
      if xf_r
        c := Math.abs(Math.cos(xf_r))
        s := Math.abs(Math.sin(xf_r))
        x = c * x + s * y
        y = s * x + c * y
      xfm_rect.x0 = img_rect.x0 + half_w - x
      xfm_rect.y0 = img_rect.y0 + half_h - y
      xfm_rect.x1 = xfm_rect.x0 + 2.0 * x
      xfm_rect.y1 = xfm_rect.y0 + 2.0 * y
    result = result ? result.union(xfm_rect) : xfm_rect.clone
  => result

// Overwrites pixeis parameter.
:intersectPixelRegion = ##
  pixels\ImageData\$
  mask\ImageData\$
  dx\n\$
  dy\n\$
  diff\b\$
  // Modify pixels to make intersection or diff of the mask.
  // Go thru all the pixels and modify the values.
  max_alpha := Math.floor(255.0 * 0.3)
    // This 0.3 needs to match the alpha in Stencil.draw_segment.
  for y := 0; y < pixels.height; y++
    for x := 0; x < pixels.width; x++
      sx := x + dx
      sy := y + dy
      stencil := 0.0

      if #&&
        sx >= 0
        sx < mask.width
        sy >= 0
        sy < mask.height
        --
        mask_alpha := mask.data[(sx + sy * mask.width) * 4 + 3]
        stencil = mask_alpha >= max_alpha ? 1.0 : mask_alpha / max_alpha
      if diff
        stencil = 1.0 - stencil
      if stencil < 1.0
        base := (x + y * pixels.width) * 4
        alpha_idx := base + 3
        alpha := #?
          stencil <= 0.0
          0
          Math.floor(pixels.data[alpha_idx] * stencil)
        if alpha == 0
          for i := 1; i < 4; i++
            pixels.data[base + i] = 0
        pixels.data[alpha_idx] = alpha

:sizedImageData = ##
  \s\
  pixels\ImageData\$
  rect\data.Rect\$
  // Takes coordinates relative to pixels.
  w := rect.w + 1
  h := rect.h + 1
  cvs := &Canvas(w, h)
  cvs.ctx.putImageData(pixels, -rect.x0, -rect.y0, rect.x0, rect.y0, w, h)
  => cvs.dataUrl()

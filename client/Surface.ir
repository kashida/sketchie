Canvas that's fixed to the viewport size.
::<Canvas
  canvas_or_w\HTMLCanvasElement|n\$
  h\n\?
  ^(canvas_or_w, h)

:activate
  img\Image\$
  alpha_lock\b\$
  // Need to match the backing store resolution with screen resolution.
  @.canvas.style.display = 'block'
  @.set_scale(f_viewport.scale())
  @.copy_image(img)
  @.update_alpha_lock(alpha_lock)

:update_alpha_lock
  alpha_lock\b\$
  @.ctx.globalCompositeOperation = alpha_lock ? 'source-atop' : 'source-over'

:deactivate
  @.clear()
  @.canvas.style.display = 'none'
  @.ctx.globalCompositeOperation = ''

Val is the opacity value [0, 1.0], but resets to default when null.
:set_opacity
  val\s\$
  @.canvas.style.opacity = val

Takes view coordinates and returns [r, g, b, a] array in [0, 255] range.
:pick_color
  x\n\$
  y\n\$
  scale := f_viewport.scale()
  pixels := @.ctx.getImageData(x / scale, y / scale, 1, 1)
  d := pixels.data
  => [d[0], d[1], d[2], d[3]]

:image_spec
  orig_img\Image\?
  // Produce image spec of this surface plus the original image.
  // Size of the image is reduced to the tight bound.
  pixels := @.pixels()
  => #?
    orig_img
    merged_image_spec(pixels, orig_img)
    image_rect_spec(pixels)

Orig_img gets added to the outside of the pixels bound.
Pixels_rect is the tight bounds of the pixels in canvas (i.e. viewport) coordinates.
:::merged_image_spec = ##
  pixels\ImageData\$
  orig_img\Image\$
  pixels_rect := find_pixel_rect(pixels)
  if !pixels_rect
    => null
  w := pixels_rect.w + 1
  h := pixels_rect.h + 1

  // Find the rect that can contain pixels_rect and the transformed image
  // in document coords.
  its := f_viewport.item_to_surface(elem_position(orig_img))
  imgx0 := its[0]
  imgy0 := its[1]
  its_br := f_viewport.item_to_surface(elem_position_br(orig_img))
  imgx1 := its_br[0]
  imgy1 := its_br[1]
  u := union_rect([orig_img], pixels_rect, [[imgx0, imgy0, imgx1, imgy1]])
  if !u
    => null
  uw := u.w + 1
  uh := u.h + 1

  // New temp canvas, logically located at (u.x0, u.y0) in surface coords.
  cvs := &Canvas(uw, uh)
  ctx := cvs.ctx
  xform_draw_image(ctx, orig_img, &data.Point(imgx0 - u.x0, imgy0 - u.y0))
  ctx.clearRect(-u.x0, -u.y0, pixels.width, pixels.height)
  ctx.putImageData(pixels, -u.x0, -u.y0, pixels_rect.x0, pixels_rect.y0, w, h)
  => image_rect_spec(cvs.pixels(), null, u.x0, u.y0)

:::image_rect_spec = ##
  \A.<n>\
  pixels\ImageData\$
  rect\data.Rect\?
  offset_x\n\? 0
  offset_y\n\? 0
  if !rect
    rect = find_pixel_rect(pixels)
    if !rect
      => null
  item_xy := f_viewport.surface_to_item(#)
    rect[0] + offset_x
    rect[1] + offset_y
  => [item_xy[0], item_xy[1], sized_image_data(pixels, rect)]

:::xform_draw_image = ##
  ctx\CanvasRenderingContext2D\$
  img\Image\$
  offset\data.Point\$
  use_alpha\b\? false
  xf_r := attr(img, 'xf_r')
  xf_s := attr(img, 'xf_s')
  alpha := use_alpha ? attr(img, 'blend_alpha') : null
  if !(xf_r || xf_s || alpha)
    ctx.drawImage(img, offset.x, offset.y)
    =>
  half_w := 0.5 * img.width
  half_h := 0.5 * img.height
  ctx.save()
  ctx.translate(offset.x + half_w, offset.y + half_h)
  if xf_r
    ctx.rotate(xf_r)
  if xf_s
    ctx.scale(xf_s, xf_s)
  if alpha
    ctx.globalAlpha = parseInt(alpha, 10) / 100.0
  ctx.drawImage(img, -half_w, -half_h)
  ctx.restore()

:::image_region = ##
  img\Image\$
  region_pixels\ImageData\$
  diff\b\? false
  // Take either intersection or diff of the images.
  cvs := &Canvas(img.width, img.height)
  cvs.ctx.drawImage(img, 0, 0)
  pixels := cvs.pixels()
  sti := f_viewport.surface_to_item(0, 0)
  mx := sti[0]
  my := sti[1]
  intersect_pixel_region(#)
    pixels
    region_pixels
    Math.floor(img.offsetLeft - mx)
    Math.floor(img.offsetTop - my)
    diff
  rect := find_pixel_rect(pixels)
  if !rect
    => null
  => [#]
    rect[0] + img.offsetLeft
    rect[1] + img.offsetTop
    sized_image_data(pixels, rect)

:::blend_images = ##
  images\A.<Image>\$
  if images.length < 1
    => null
  ur := union_rect(images)
  minx := ur.x0
  miny := ur.y0
  maxx := ur.x1
  maxy := ur.y1
  w := maxx - minx + 1
  h := maxy - miny + 1
  cvs := &Canvas(w, h)
  ctx := cvs.ctx
  images.forEach(##)
    img\Image\$
    xform_draw_image(ctx, img, &data.Point(#), true)
      img.offsetLeft - minx
      img.offsetTop - miny

  // Now we have the image. Find a tighter bound.
  pixels := cvs.pixels()
  rect := find_pixel_rect(pixels)
  if !rect
    => null
  => [#]
    rect[0] + minx
    rect[1] + miny
    sized_image_data(pixels, rect)

:::find_pixel_rect = ##
  \data.Rect\
  pixels\ImageData\$
  // Find the rectangle in the image where pixels actually have colors.
  // Resulting coordinates are relative to the pixels.
  miny := minx := maxy := maxx := null
  has_value := ##
    x\n\$
    y\n\$
    // only check alpha.
    => pixels.data[(x + y * pixels.width) * 4 + 3] > 0

  // Find the minimum and maximum y values that has any pixel.
  row_has_value := ##
    y\n\$
    for x := 0; x < pixels.width; x++
      if has_value(x, y)
        => true
    => false
  for y := 0; y < pixels.height; y++
    if row_has_value(y)
      miny = y
      break
  if !miny
    => null
  for y = pixels.height - 1; y >= miny; y--
    if row_has_value(y)
      maxy = y
      break
  if !maxy
    => null

  // Find the minimum and maximum x values that has any pixel.
  col_has_value := ##
    x\n\$
    for y = miny; y <= maxy; y++
      if has_value(x, y)
        => true
    => false
  for x := 0; x < pixels.width; x++
    if col_has_value(x)
      minx = x
      break
  if !minx
    => null
  for x = pixels.width - 1; x >= minx; x--
    if col_has_value(x)
      maxx = x
      break
  if !maxx
    => null
  => &data.Rect(minx, miny, maxx, maxy)

:::union_rect = ##
  \data.Rect\
  images\A.<Image>\$
  init_rect\data.Rect\?
  image_dimensions\A\? []
  if images.length < 1
    => null
  result := init_rect ? init_rect.clone : null
  images.forEach(##)
    img\Image\$
    i\n\$
    imgx0 := img.offsetLeft
    imgy0 := img.offsetTop
    imgx1 := img.offsetLeft + img.offsetWidth
    imgy1 := img.offsetTop + img.offsetHeight
    if image_dimensions.length > i
      imgx0 = image_dimensions[i][0]
      imgy0 = image_dimensions[i][1]
      imgx1 = image_dimensions[i][2]
      imgy1 = image_dimensions[i][3]
    xf_r := attr(img, 'xf_r')
    xf_s := attr(img, 'xf_s')
    if !(xf_r || xf_s)
      x0 := imgx0
      y0 := imgy0
      x1 := imgx1
      y1 := imgy1
    else
      half_w := 0.5 * (imgx1 - imgx0)
      half_h := 0.5 * (imgy1 - imgy0)
      // Corner coord from the center of the image (doesn't matter which
      // corner).
      x := half_w
      y := half_h
      if xf_s
        x = x * xf_s
        y = y * xf_s
      if xf_r
        c := Math.abs(Math.cos(xf_r))
        s := Math.abs(Math.sin(xf_r))
        x = c * x + s * y
        y = s * x + c * y
      x0 = imgx0 + half_w - x
      y0 = imgy0 + half_h - y
      x1 = x0 + 2.0 * x
      y1 = y0 + 2.0 * y
    if result
      result.x0 = Math.max(result.x0, x0)
      result.y0 = Math.max(result.y0, y0)
      result.x1 = Math.max(result.x1, x1)
      result.y1 = Math.max(result.y1, y1)
    else
      result = &data.Rect(x0, y0, x1, y1)
  => result

:::intersect_pixel_region = ##
  pixels\ImageData\$
  region_pixels\ImageData\$
  dx\n\$
  dy\n\$
  diff\b\$
  // Modify pixels to make intersection or diff of the region_pixels.
  // Go thru all the pixels and modify the values.
  max_alpha := Math.floor(255.0 * 0.3)
    // This 0.3 needs to match the alpha in Stencil.draw_segment.
  for y := 0; y < pixels.height; y++
    for x := 0; x < pixels.width; x++
      sx := x + dx
      sy := y + dy
      stencil := 0.0

      if #&&
        sx >= 0
        sx < region_pixels.width
        sy >= 0
        sy < region_pixels.height
        --
        stencil_alpha := region_pixels.data[#]
          (sx + sy * region_pixels.width) * 4 + 3
        stencil = stencil_alpha >= max_alpha ? 1.0 : stencil_alpha / max_alpha
      if diff
        stencil = 1.0 - stencil
      if stencil < 1.0
        base := (x + y * pixels.width) * 4
        alpha_idx := base + 3
        alpha := #?
          stencil <= 0.0
          0
          Math.floor(pixels.data[alpha_idx] * stencil)
        if alpha == 0
          each i in [1, 2, 3]
            pixels.data[base + i] = 0
        pixels.data[alpha_idx] = alpha

:::sized_image_data = ##
  pixels\ImageData\$
  rect\data.Rect\$
  // Takes coordinates relative to pixels.
  w := rect.w + 1
  h := rect.h + 1
  cvs := &Canvas(w, h)
  cvs.ctx.putImageData(pixels, -rect.x0, -rect.y0, rect.x0, rect.y0, w, h)
  => cvs.data_url()
